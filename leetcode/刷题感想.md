# 刷题感想

1. 题2：[Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers/)

   <img src="pic\image-20200627132939504.png" alt="2题目" style="zoom:67%;" />

   存储的是链表形式，按照逆序排列，输出也按照逆序：就是按照**手工计算的顺序**，最后一位先计算，有进位就给前一位，一直到最高位，最高位有进位需要增加一个新位。并且位之间要对齐

   算法思想很简单，就是具体细节要注意

   - 初始化一个val=0的节点，代表结果链表的头结点，最后要将其跳过`return returnValue.next`
   - 如果两个加数不一样长度，那么高位需要补0，再计算，所以要先判断`p != null`?

   ps：不能遍历将其转换为整数，然后计算，会溢出；也不用转置

   :book:：学到一个变量名： `dummyHead`（官方解答里出现）——代表哨兵节点/头节点——在内核代码中也看到过多次关于`dummy`  

2. 题1431：[Kids With the Greatest Number of Candies](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)

   <img src="pic\image-20200627142658823.png" alt="1431题目" style="zoom: 50%;" />

   题目本身很简答，主要策略：遍历数组找到最大值，然后再次遍历数组，对每个值都加上extra，看结果是否>=最大值，如果true——表示可以，赋值为true；否则，表示即使加上extra，也无法达到最大，赋值为false。

   :book:：

   - Java有一个自带的库：Math，不需要导入package，就可以直接使用。

     ```java
     // Math.min
     int x = Math.min(a, b);	// 求a，b之间的最小值，返回值——具体的值
     // Math.max，同上
     // Math.PI——内置的圆周率，是一个double类型的数据
     // Math.abs
     int a = Math.abs(x);	// 求某值的绝对值
     // .... 还有很多，具体可以在eclipse中尝试
     ```

   - ArrayList用法

     ArrayList是List接口的一个实现类，关于ArrayList和List的区别：[这篇博客写的很好](https://blog.csdn.net/erlian1992/article/details/51298276)

     （1）需要导入包：

     ```java
     import java.util.ArrayList; // import the ArrayList class
     ```

     （2）new一个ArrayList对象：

     ```java
     ArrayList<String>fruit = new ArrayList<String>();	// 该对象存储的是字符串，对象名为fruit
     ```

     :warning:：这里的类型是一个对象：String——**对象，而不是原始类型**，如果要使用其他类型，eg：bool、char、int、double等，**都需要指定等效的包装器类**：

     <img src="pic\image-20200627161050020.png" alt="等效包装器类" style="zoom: 50%;" />

     （3）一些有用的方法：

     ```java
     ArrayList<String>fruit = new ArrayList<String>();		// 新建一个对象
     
     // add，添加元素
     fruit.add("apple");
     fruit.add("orange");
     
     // 可以直接将对象中的元素打印出来
     System.out.println(fruit);		// [apple]
     
     // get，获得指定下标的元素
     fruit.get(0);			// apple
     
     // set，设置指定下标的元素的值
     fruit.set(0, "banana");		// apple -> banana
     
     // remove，将指定下标的元素移除
     fruit.remove(1);			// orange x
     
     // clear，清空该对象
     fruit.clear();
     
     // size，求对象中的元素个数
     fruit.size();
     
     // 可以简单for循环
     for(String i: fruit){ .... }	// i即为里面的元素，而不是索引
     ```

     （4）排序：

     ```java
     // 排序需要导入Collections包，里面包含sort方法——能够按照字母或者数字对列表排列
     import java.util.Collections;  // Import the Collections class
     
     Collections.sort(fruit);	// 升序排列
     ```

   - 为什么用 List list = new ArrayList() ，而不用 ArrayList alist = new ArrayList()？

      **list拥有List的所有属性和方法，不会拥有ArrayList的独有的属性和方法**。

     这是**为了方便替换**，List有多个实现类，目前用的是ArrayList，如果之后要换成其他类，例如LinkList、Vector等，那么只需要换新建的这一行即可，而不需要修改后面的代码。如果直接用ArrayList，每一个语句都要修改，而且那么关于ArrayList特有的方法的地方需要重新实现 

3. 题19：[Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

   这题是链表题

   <img src="pic\image-20200628152203810.png" alt="19题目" style="zoom:67%;" />

   常规思路：先遍历一遍链表，求得链表长度，然后计算得到正序的删除数。再次遍历链表到指定位置删除。

   :warning:注意：需要注意边界：如果要删除的是头结点/或者只有一个元素，并且要将其删除，那么需要特殊处理

   所以官方给的常规解法中用了**哨兵结点**（题2也用到了）——在学习数据结构中，遇到过，设置一个头指针（该指针为空，指向实际的链表头），可以**来避免越界或者对链表头的操作**

   :book:学到了：在链表中，**dummy结点**使用频率很高：一般就是新建一个结点dummy，dummy.next = head，那么**链表头结点的操作就跟普通结点的操作一样了**。然后根据实际情况操作，最后一般返回的是 `return dummy.next`（实际的链表头）

   :bulb:进阶：一次扫描——设置两个指针：first、second，两个指针间隔n个结点，即first先走n+1次。然后first和second再走，这样当first遍历完成后（在链表尾的后一个结点），second就指向了要删除结点的前一个

   <img src="pic\image-20200628153504672.png" alt="具体图示" style="zoom: 67%;" />

   :boxing_glove:总结：普通解法时间复杂度`O(L+L-n)=O(L)`，进阶的时间复杂度`O(L)`，空间复杂度都是`O(1)`，学到了双指针的巧妙用法。:happy: 更妙的是，dummy结点的使用。

4. 题21：[Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

   <img src="pic\image-20200628170755766.png" alt="21题目" style="zoom:67%;" />

   这题在数据结构的链表学习中几乎必见

   常规做法：从两个链表的头开始遍历，找到更小的结点加入，最后一个链表先结束，则将另一个链表的剩余全部归入。

   复杂做法：递归（作为一个递归废，我并不喜欢用） [这篇文章写的很好，特别是图解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)，具体看程序（描述不出来）

   :boxing_glove:总结：自己写的解里面终于用到了 dummy！:bulb:：递归很重要，以后要有重点的练一下这个（找几个典型的题，培养一下感觉）

   ps：承包了我一天的笑点的图：

   <img src="pic\recursive.png" alt="递归" style="zoom:67%;" />

5. 题27：[移除元素](https://leetcode-cn.com/problems/remove-element/)

   <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20200629105302812.png" alt="题27" style="zoom:67%;" />

   题目要求的是，更改数组，将删除后的数组元素全部向前移。

   暴力解法：遍历数组，发现有目标的，就把之后的元素全部向前移动（但是超时了）

   官方提供的方法：

   - 两个指针，一个指针 first 遍历，另一指针 second 指向最新数组当前长度：first 遍历数组，发现非删除元素，就赋值给 second，并且更新second指针

     => 适用于要删除的元素多

   - 两个指针，一个指针 head 指向头部，另一个指针 tail 指向尾部，从 head 开始遍历，遇到删除元素，就将尾部指针的元素替换到 head，并且更新 tail；如果是非删除元素，更新 head。

     => 适用于要删除的元素较少

   :boxing_glove:：核心是使用双指针：一个走快点一个走慢点；一个指向头一个指向尾。:bulb: 要学会使用双指针（题19也使用了）​

6. 题206：[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

   <img src="pic\image-20200701143536418.png" alt="题207" style="zoom:67%;" />

   题目意思：将链表逆序，原来的链表头变成链表尾，原来的尾变成头

   我的思路：迭代，用3个指针：prev（前驱指针）、curr（当前指针）、succ（后继指针），分别用来标记3个结点。从前向后不断逆转。由于保存了三个结点，所以不会丢失

   另一种思路：递归（想到也不会实现），[这篇文章写的很好]( https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/ )，就是先递归一直找到链表尾，然后从后向前不断操作，由于递归的时候，自动保存了当前结点（head），而需要修改的是，当前结点$n_k$的next指向，$n_k.next.next = n_k$，并且注意细节$n_1.next = null$（只需要每次最后将$n_k.next = null$即可，因为下一个递归还会保存当前结点，即$n_{k-1}$）

   <img src="pic\image-20200701144403080.png" alt="解释递归" style="zoom:67%;" />

   :boxing_glove:：递归真的巧妙，默认保存当前结点。可惜我只会迭代，现在多练练递归感觉。

7. 题26：[删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

   <img src="pic\image-20200701153348563.png" alt="题26" style="zoom:67%;" />

   思路：设置双指针，然后一个用来遍历，一个用来更新无重复的数组

   实现比较简单，就是要考虑临界条件：当数组为空的时候的操作（我觉得通过率低，应该都是没有考虑临界条件造成的）

   :book: ：这边解释了一个leetcode题目的常见问题：数组传递的都是指针（实参），所以对函数里对数组的修改是有效的（而不是，退出该函数，修改就消失了，形参的问题）

   所以，传递最新数组值，就能判断操作是否正确（至于该值后面的数组元素就不考虑了）。

   <img src="pic\image-20200701153521826.png" alt="形参和实参的传递" style="zoom:67%;" />

   :boxing_glove:：双指针真好用:+1:

8. 题328：[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)

   <img src="pic\image-20200701165032642.png" alt="题328" style="zoom:67%;" />

   一开始没有理解原地的意思（实际上，链表的操作好像都是原地的）。

   空间复杂度O(1)：可以创建常量个变量；时间复杂度O(nodes)：遍历一次

   具体思路很简单：设置两个指针，分别代表奇数链表、偶数链表，然后遍历链表，将他们拆分成两个链表即可，最后将偶数链表插入到奇数链表尾就可以了，我采用的是3指针：一个代表奇数链表的当前结点odd、一个代表偶数链表的当前结点even、一个代表当前结点curr。

   :warning:：特别要注意的是，对于每个当前结点，加入到对应的链表后，要将next指针清除掉，即`curr.next = null;`（这样主要是为了防止偶数尾结点和奇数尾结点产生循环）

   <img src="pic\image-20200701170039436.png" alt="死循环" style="zoom:67%;" />

   题解的方法更优雅；主要是关注到，只需要将even从链表中剔除，那么通过even来遍历，而odd做辅助就行，大致思路和我差不多，实现起来更简单。

   :boxing_glove:：官方解法好优雅，学不来:pensive:，只能多看看

9. 题876：[链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

   <img src="pic\image-20200702105909505.png" alt="题876" style="zoom:67%;" />

   我的思路：遍历链表求得链表长度，再次从头开始找到中间结点。

   缺点：当链表很长时，将花费很多时间在第二次遍历上。

   更优的思路：快慢指针解法，快指针每次走一步，慢指针每两次走一步，那么快指针遍历完后，慢指针一定指向中间结点。

   而且，官方的题解的解法比我实现的更好：

   ```java
   ListNode first = head, second = head;	// 快慢指针
   while(first != null && first.next != null){	// 一次走两步的遍历
       second = second.next;
       first = first.next.next;
   }
   return second;
   ```

   :boxing_glove:：链表题要考虑是否能用双指针/快慢指针

10. 题11：[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

    <img src="pic\image-20200702133221610.png" alt="题11" style="zoom:67%;" />

    首先拿到题目，先将题目抽象了，本质上是：求数组中两个结点 `(min(node1, node2)) * (index1 - index2)`（我能分析到这步，但是接下去就不知道该如何做了）

    官方题解：**双指针**，一个首head、一个尾tail，开始遍历，直到两个指针相交。那么这两个结点开始如何移动呢？接着我的分析，head从0开始，tail从len-1，开始，先计算最远的两个结点构成的面积，然后移动两个结点之间数值小的那个索引，即`num[head], num[tail]`中小的head/tail，eg：num[head] = 1, num[tail] = 8，那么就是head++，这构成了移动条件。

    证明选择较小的移动是正确的：

    $\because area = (tail - head) * min(num[tail], num[head])$，面积值由两部分组成，两者的距离和两者的值，所以一开始选择首尾，前一个数最大，循环过程中开始缩小，且每次缩小数都-1。

    为啥选择值小的那个index移动？ 反例，如果选择值大的index移动，那么 前一个乘数变小，后一个乘数**只能保持小于等于**（因为是min，所以取决于最小，因为值大的移动，那么如果移动到更大的一个值，也无济于事；如果移动到比原来小的值更小） ；$\therefore$ 选择值小的index移动，那么min才可能会变大

    $\therefore$ 这样的算法是正确的。[这个题解讲的很好]( https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ )

    :boxing_glove: 算法实现很简单，具体的分析和证明很重要（这题就是很主要在设计算法）。我能将题目抽象出来，并且分析出了关键的影响面积的因素，但是由于没有考虑到双指针的解法，所以就无从下手，所以:bulb: 双指针还是要多练练。:bulb: 并且，选择移动的条件也是算法的关键。

11. 题7：[整数反转](https://leetcode-cn.com/problems/reverse-integer/)

    <img src="pic\image-20200703105820590.png" alt="题7" style="zoom:67%;" />

    整数反转，一开始的思路是转换成string类型，倒置后再转换成int类型，但int转string效率不高。所以转而使用数学方法——不断取余，递增，相除循环。:key:最关键的是，要对溢出进行判断，输入是不会溢出的，但是倒置之后可能会溢出：向上溢出，向下溢出，所以要提前判断`Integer.MAX_VALUE / 10`和`Integer.MIN_VALUE / 10`，具体看代码实现。

    :boxing_glove:对于基础算法还是要记得：普通的数字倒转。

12. 题24：[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

    <img src="pic\image-20200703123904443.png" alt="题24" style="zoom:67%;" />

    这个题我的思路是，迭代解法，用了3指针：head、second、temp，head指向第一个要替换的结点，second指向第二个要替换的结点，temp指向前面已经替换好的链表尾。还设置了dummy（哨兵结点），用来保存头结点，方便返回。具体画图就可得。

    官方提供了递归的解法：使用了两个指针。明确终止条件：head和head.next为null；调用单元：head和next进行交换，其中head的next指向后面已经交换好的链表头；返回值，后面交换完成的链表头。[这个写的很好，特别是关于递归的基础]( https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/ )

    :book:递归的解题思路：需要分析出：1. 终止条件（一般在函数头指明）；2. 调用单元：一般在中间部分，需要具体分析，且包括递归调用；3. 返回值：一般出现在函数尾部，也一般是整个函数的返回值

    <img src="pic\image-20200703123829758.png" alt="递归图解" style="zoom: 67%;" />

    :boxing_glove:递归如何写优雅需要学习

13. 题121：[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

    <img src="pic\image-20200718221014141.png" alt="image-20200718221014141" style="zoom:67%;" />

    我的解法：暴力解:sweat:，时间复杂度：O(n^2)

    聪明的解法：一次遍历，遍历的点是要卖出的点，那么其所属的**历史最低点**就是最优的买入点，两者的差值就是该点下获利最多的情况。那么维护一个`minprice`——历史最低点；`maxprofit`——获利最大值。（历史最低点：就是在点之前，价格最低的点）

    :boxing_glove:这种数学性质的题比较灵活，很明显暴力解不是最优，但是能解决问题——所以应该先实现暴力解法。然后去分析更优解

14. 题283：[移动零](https://leetcode-cn.com/problems/move-zeroes/)

    <img src="pic\image-20200718225955189.png" alt="image-20200718225955189" style="zoom:67%;" />

    我的解法：一次遍历，利用两个指针，`first`——用来遍历，`second`——用来指示最新数组非零数和零数之间的间隔。当遇到0值的时候跳过，遇到非0值得时候first和second所指示的值交换——具体看代码。[讲的很好的题解]( https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/ )

    <img src="pic\283_answer_gif.gif" alt="一次遍历的动图" style="zoom:67%;" />

15. 题35：[搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

    <img src="pic\image-20200806111428332.png" alt="image-20200806111428332" style="zoom: 67%;" />

    题目本身没啥难度，但是可以根据这个接触**二分查找**

    我的解法：:cold_sweat:暴力解​，时间复杂度最差会到O(n)

    :+1:二分查找：时间复杂度是O(logn)，认识的关键是**严格小于目标数的都不可能是解**，只有大于目标的才有可能是解，然后不断收缩 right 的范围，并更新解索引；当遇到小于目标值时，单纯缩小left范围

16. 题704：[二分查找](https://leetcode-cn.com/problems/binary-search/)

    <img src="pic\image-20200806173503684.png" alt="image-20200806173503684" style="zoom:67%;" />

    很典型的二分查找题，不需要变型，直接套用即可。

17. 题34：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

    <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20200807101918176.png" alt="image-20200807101918176" style="zoom:67%;" />

    典型的二分查找寻找边界的问题，具体见之前的整理

18. 题69：[x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

    <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20200807112353923.png" alt="image-20200807112353923" style="zoom:67%;" />

    求平方根，选择使用了二分查找。类似于普通的二分查找的方式，但是由于一定是有解的，所以不会返回-1，而是等到循环结束之后，指针指向的值就是正解。

    :bulb:可以在纸上模仿运行一下，看边界条件和返回值。

    查找边界：[1, x - 1]（排除了0，1之后）,双闭区间，所以循环是`left <= right`，并且最后由于循环停止条件为`left = right + 1`，所以正解为`left-1`处

    :boxing_glove:其余方法是数学原理

19. 