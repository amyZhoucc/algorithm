# 刷题感想

## day1

1. 题2：[Add Two Numbers](https://leetcode-cn.com/problems/add-two-numbers/)

   <img src="pic\image-20200627132939504.png" alt="2题目" style="zoom:67%;" />

   存储的是链表形式，按照逆序排列，输出也按照逆序：就是按照**手工计算的顺序**，最后一位先计算，有进位就给前一位，一直到最高位，最高位有进位需要增加一个新位。并且位之间要对齐

   算法思想很简单，就是具体细节要注意

   - 初始化一个val=0的节点，代表结果链表的头结点，最后要将其跳过`return returnValue.next`
   - 如果两个加数不一样长度，那么高位需要补0，再计算，所以要先判断`p != null`?

   ps：不能遍历将其转换为整数，然后计算，会溢出；也不用转置

   :book:：学到一个变量名： `dummyHead`（官方解答里出现）——代表哨兵节点/头节点——在内核代码中也看到过多次关于`dummy`  

2. 题1431：[Kids With the Greatest Number of Candies](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)

   <img src="pic\image-20200627142658823.png" alt="1431题目" style="zoom: 50%;" />

   题目本身很简答，主要策略：遍历数组找到最大值，然后再次遍历数组，对每个值都加上extra，看结果是否>=最大值，如果true——表示可以，赋值为true；否则，表示即使加上extra，也无法达到最大，赋值为false。

   :book:：

   - Java有一个自带的库：Math，不需要导入package，就可以直接使用。

     ```java
     // Math.min
     int x = Math.min(a, b);	// 求a，b之间的最小值，返回值——具体的值
     // Math.max，同上
     // Math.PI——内置的圆周率，是一个double类型的数据
     // Math.abs
     int a = Math.abs(x);	// 求某值的绝对值
     // .... 还有很多，具体可以在eclipse中尝试
     ```

   - ArrayList用法

     ArrayList是List接口的一个实现类，关于ArrayList和List的区别：[这篇博客写的很好](https://blog.csdn.net/erlian1992/article/details/51298276)

     （1）需要导入包：

     ```java
     import java.util.ArrayList; // import the ArrayList class
     ```

     （2）new一个ArrayList对象：

     ```java
     ArrayList<String>fruit = new ArrayList<String>();	// 该对象存储的是字符串，对象名为fruit
     ```

     :warning:：这里的类型是一个对象：String——**对象，而不是原始类型**，如果要使用其他类型，eg：bool、char、int、double等，**都需要指定等效的包装器类**：

     <img src="pic\image-20200627161050020.png" alt="等效包装器类" style="zoom: 50%;" />

     （3）一些有用的方法：

     ```java
     ArrayList<String>fruit = new ArrayList<String>();		// 新建一个对象
     
     // add，添加元素
     fruit.add("apple");
     fruit.add("orange");
     
     // 可以直接将对象中的元素打印出来
     System.out.println(fruit);		// [apple]
     
     // get，获得指定下标的元素
     fruit.get(0);			// apple
     
     // set，设置指定下标的元素的值
     fruit.set(0, "banana");		// apple -> banana
     
     // remove，将指定下标的元素移除
     fruit.remove(1);			// orange x
     
     // clear，清空该对象
     fruit.clear();
     
     // size，求对象中的元素个数
     fruit.size();
     
     // 可以简单for循环
     for(String i: fruit){ .... }	// i即为里面的元素，而不是索引
     ```

     （4）排序：

     ```java
     // 排序需要导入Collections包，里面包含sort方法——能够按照字母或者数字对列表排列
     import java.util.Collections;  // Import the Collections class
     
     Collections.sort(fruit);	// 升序排列
     ```

   - 为什么用 List list = new ArrayList() ，而不用 ArrayList alist = new ArrayList()？

      **list拥有List的所有属性和方法，不会拥有ArrayList的独有的属性和方法**。

     这是**为了方便替换**，List有多个实现类，目前用的是ArrayList，如果之后要换成其他类，例如LinkList、Vector等，那么只需要换新建的这一行即可，而不需要修改后面的代码。如果直接用ArrayList，每一个语句都要修改，而且那么关于ArrayList特有的方法的地方需要重新实现 

3. 题19：[Remove Nth Node From End of List](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

   这题是链表题

   <img src="pic\image-20200628152203810.png" alt="19题目" style="zoom:67%;" />

   常规思路：先遍历一遍链表，求得链表长度，然后计算得到正序的删除数。再次遍历链表到指定位置删除。

   :warning:注意：需要注意边界：如果要删除的是头结点/或者只有一个元素，并且要将其删除，那么需要特殊处理

   所以官方给的常规解法中用了**哨兵结点**（题2也用到了）——在学习数据结构中，遇到过，设置一个头指针（该指针为空，指向实际的链表头），可以**来避免越界或者对链表头的操作**

   :book:学到了：在链表中，**dummy结点**使用频率很高：一般就是新建一个结点dummy，dummy.next = head，那么**链表头结点的操作就跟普通结点的操作一样了**。然后根据实际情况操作，最后一般返回的是 `return dummy.next`（实际的链表头）

   :bulb:进阶：一次扫描——设置两个指针：first、second，两个指针间隔n个结点，即first先走n+1次。然后first和second再走，这样当first遍历完成后（在链表尾的后一个结点），second就指向了要删除结点的前一个

   <img src="pic\image-20200628153504672.png" alt="具体图示" style="zoom: 67%;" />

   :boxing_glove:总结：普通解法时间复杂度`O(L+L-n)=O(L)`，进阶的时间复杂度`O(L)`，空间复杂度都是`O(1)`，学到了双指针的巧妙用法。:happy: 更妙的是，dummy结点的使用。

4. 题21：[Merge Two Sorted Lists](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

   <img src="pic\image-20200628170755766.png" alt="21题目" style="zoom:67%;" />

   这题在数据结构的链表学习中几乎必见

   常规做法：从两个链表的头开始遍历，找到更小的结点加入，最后一个链表先结束，则将另一个链表的剩余全部归入。

   复杂做法：递归（作为一个递归废，我并不喜欢用） [这篇文章写的很好，特别是图解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)，具体看程序（描述不出来）

   :boxing_glove:总结：自己写的解里面终于用到了 dummy！:bulb:：递归很重要，以后要有重点的练一下这个（找几个典型的题，培养一下感觉）

   ps：承包了我一天的笑点的图：

   <img src="pic\recursive.png" alt="递归" style="zoom:67%;" />

5. 题27：[移除元素](https://leetcode-cn.com/problems/remove-element/)

   <img src="C:\Users\surface\AppData\Roaming\Typora\typora-user-images\image-20200629105302812.png" alt="题27" style="zoom:67%;" />

   题目要求的是，更改数组，将删除后的数组元素全部向前移。

   暴力解法：遍历数组，发现有目标的，就把之后的元素全部向前移动（但是超时了）

   官方提供的方法：

   - 两个指针，一个指针 first 遍历，另一指针 second 指向最新数组当前长度：first 遍历数组，发现非删除元素，就赋值给 second，并且更新second指针

     => 适用于要删除的元素多

   - 两个指针，一个指针 head 指向头部，另一个指针 tail 指向尾部，从 head 开始遍历，遇到删除元素，就将尾部指针的元素替换到 head，并且更新 tail；如果是非删除元素，更新 head。

     => 适用于要删除的元素较少

   :boxing_glove:：核心是使用双指针：一个走快点一个走慢点；一个指向头一个指向尾。:bulb: 要学会使用双指针（题19也使用了）​

6. 