# 刷题感想

## 列表

1. [题2. 两数相加](#num2)
2. [题7. 整数反转](#num7)
3. [题11. 盛最多水的容器](#num11)
4. [题19. 删除链表的倒数第N个节点](#num19)
5. [题21. 合并两个有序链表](#num21)
6. [题24. 两两交换链表中的节点](#num24)
7. [题26.删除排序数组中的重复项](#num26)
8. [题27. 移除元素](#num27)
9. [题34. 在排序数组中查找元素的第一个和最后一个位置](#num34)
10. [题35. 搜索插入位置](#num35)
11. [题69. x的平方根](#num69)
12. [题100. 相同的树](#num100)
13. [题101. 对称二叉树](#num101)
14. [题102. 二叉树的层序遍历](#num102)
15. [题104. 二叉树的最大深度](#num104)
16. [题105. 从前序与中序遍历序列构造二叉树](#num105)（未完）
17. [题111. 二叉树的最小深度](#num111)
18. [题112. 路径总和](#num112)
19. [题121. 买卖股票的最佳时机](#num121)
20. [题134. 加油站](#num134)
21. [题142. 环形链表II](#num142)
22. [题144、94、145. 二叉树的前序、中序、后序遍历](#traversal_binaryTree)
23. [题198. 打家劫舍](#num198)
24. [题206. 反转链表](#num206)
25. [题226. 翻转二叉树](#num226)
26. [题283. 移动零](#num283)
27. [题328. 奇偶链表](#num328)
28. [题344. 反转字符串](#num344)
29. [题349. 两个数组的交集](#num349)
30. [题441. 排列硬币](#num441)
31. [题559. N叉树的最大深度](#num559)
32. [题617. 合并二叉树](#num617)
33. [题654. 最大二叉树](#num654)
34. [题657. 机器人能否返回原点](#num657)
35. [题704. 二分查找](#num704)
36. [题771. 宝石与石头](#num771)
37. [题876. 链表的中间结点](#num876)
38. [题965. 单值二叉树](#num965)
39. [题1431. 拥有最多糖果的孩子](#num1431)
40. [题1480. 一维数组的动态和](#num1480)
41. [Offer 53-1. 在排序数组中查找数字 I](#offer53-1)
42. [Offer 32-I. 从上到下打印二叉树](#offer32-1)
43. [Offer 32-III. 从上到下打印二叉树 III](#offer32-3)
44. 

## 题解

1. 题2：[两数相加](https://leetcode-cn.com/problems/add-two-numbers/)<a name="num2"></a>

   <img src="pic\image-20200627132939504.png" alt="2题目" style="zoom:67%;" />

   存储的是链表形式，按照逆序排列，输出也按照逆序：就是按照**手工计算的顺序**，最后一位先计算，有进位就给前一位，一直到最高位，最高位有进位需要增加一个新位。并且位之间要对齐

   算法思想很简单，就是具体细节要注意

   - 初始化一个val=0的节点，代表结果链表的头结点，最后要将其跳过`return returnValue.next`
   - 如果两个加数不一样长度，那么高位需要补0，再计算，所以要先判断`p != null`?

   ps：不能遍历将其转换为整数，然后计算，会溢出；也不用转置

   :book:：学到一个变量名： `dummyHead`（官方解答里出现）——代表哨兵节点/头节点——在内核代码中也看到过多次关于`dummy`  

2. 题1431：[拥有最多糖果的孩子](https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)<a name="num1431"></a>

   <img src="pic\image-20200627142658823.png" alt="1431题目" style="zoom: 50%;" />

   题目本身很简答，主要策略：遍历数组找到最大值，然后再次遍历数组，对每个值都加上extra，看结果是否>=最大值，如果true——表示可以，赋值为true；否则，表示即使加上extra，也无法达到最大，赋值为false。

   :book:：

   - Java有一个自带的库：Math，不需要导入package，就可以直接使用，能够直接使用很多的科学计算

     ```java
     // Math.min
     int x = Math.min(a, b);	// 求a，b之间的最小值，返回值——具体的值
     // Math.max，同上
     // Math.PI——内置的圆周率，是一个double类型的数据
     // Math.abs
     int a = Math.abs(x);	// 求某值的绝对值
     // .... 还有很多，具体可以在eclipse中尝试
     ```

3. 题19：[删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)<a name="num19"></a>

   这题是链表题

   <img src="pic\image-20200628152203810.png" alt="19题目" style="zoom:67%;" />

   常规思路：先遍历一遍链表，求得链表长度，然后计算得到正序的删除数。再次遍历链表到指定位置删除。

   :warning:注意：需要注意边界：如果要删除的是头结点/或者只有一个元素，并且要将其删除，那么需要特殊处理

   所以官方给的常规解法中用了**哨兵结点**（题2也用到了）——在学习数据结构中，遇到过，设置一个头指针（该指针为空，指向实际的链表头），可以**来避免越界或者对链表头的操作**

   :book:学到了：在链表中，**dummy结点**使用频率很高：一般就是新建一个结点dummy，dummy.next = head，那么**链表头结点的操作就跟普通结点的操作一样了**。然后根据实际情况操作，最后一般返回的是 `return dummy.next`（实际的链表头）

   :bulb:进阶：一次扫描——设置两个指针：first、second，两个指针间隔n个结点，即first先走n+1次。然后first和second再走，这样当first遍历完成后（在链表尾的后一个结点），second就指向了要删除结点的前一个

   <img src="pic\image-20200628153504672.png" alt="具体图示" style="zoom: 67%;" />

   :boxing_glove:总结：普通解法时间复杂度`O(L+L-n)=O(L)`，进阶的时间复杂度`O(L)`，空间复杂度都是`O(1)`，学到了双指针的巧妙用法。:happy: 更妙的是，dummy结点的使用。

4. 题21：[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)<a name="num21"></a>

   <img src="pic\image-20200628170755766.png" alt="21题目" style="zoom:67%;" />

   这题在数据结构的链表学习中几乎必见

   常规做法：从两个链表的头开始遍历，找到更小的结点加入，最后一个链表先结束，则将另一个链表的剩余全部归入。

   复杂做法：递归（作为一个递归废，我并不喜欢用） [这篇文章写的很好，特别是图解](https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/yi-kan-jiu-hui-yi-xie-jiu-fei-xiang-jie-di-gui-by-/)，具体看程序（描述不出来）

   :boxing_glove:总结：自己写的解里面终于用到了 dummy！:bulb:：递归很重要，以后要有重点的练一下这个（找几个典型的题，培养一下感觉）

   ps：承包了我一天的笑点的图：

   <img src="pic\recursive.png" alt="递归" style="zoom:67%;" />

5. 题27：[移除元素](https://leetcode-cn.com/problems/remove-element/)<a name="num27"></a>

   <img src="pic\image-20200828100257748.png" alt="image-20200828100257748"  />

   题目要求的是，更改数组，将删除后的数组元素全部向前移。

   暴力解法：遍历数组，发现有目标的，就把之后的元素全部向前移动（但是超时了）

   官方提供的方法：

   - 两个指针，一个指针 first 遍历，另一指针 second 指向最新数组当前长度：first 遍历数组，发现非删除元素，就赋值给 second，并且更新second指针

     => 适用于要删除的元素多

   - 两个指针，一个指针 head 指向头部，另一个指针 tail 指向尾部，从 head 开始遍历，遇到删除元素，就将尾部指针的元素替换到 head，并且更新 tail；如果是非删除元素，更新 head。

     => 适用于要删除的元素较少

   :boxing_glove:：核心是使用双指针：一个走快点一个走慢点；一个指向头一个指向尾。:bulb: 要学会使用双指针（题19也使用了）​

6. 题206：[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)<a name="num206"></a>

   <img src="pic\image-20200701143536418.png" alt="题207" style="zoom:67%;" />

   题目意思：将链表逆序，原来的链表头变成链表尾，原来的尾变成头

   我的思路：迭代，用3个指针：prev（前驱指针）、curr（当前指针）、succ（后继指针），分别用来标记3个结点。从前向后不断逆转。由于保存了三个结点，所以不会丢失

   另一种思路：递归（想到也不会实现），[这篇文章写的很好]( https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/ )，就是先递归一直找到链表尾，然后从后向前不断操作，由于递归的时候，自动保存了当前结点（head），而需要修改的是，当前结点$n_k$的next指向，$n_k.next.next = n_k$，并且注意细节$n_1.next = null$（只需要每次最后将$n_k.next = null$即可，因为下一个递归还会保存当前结点，即$n_{k-1}$）

   <img src="pic\image-20200701144403080.png" alt="解释递归" style="zoom:67%;" />

   :boxing_glove:：递归真的巧妙，默认保存当前结点。可惜我只会迭代，现在多练练递归感觉。

7. 题26：[删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)<a name="num26"></a>

   <img src="pic\image-20200701153348563.png" alt="题26" style="zoom:67%;" />

   思路：设置双指针，然后一个用来遍历，一个用来更新无重复的数组

   实现比较简单，就是要考虑临界条件：当数组为空的时候的操作（我觉得通过率低，应该都是没有考虑临界条件造成的）

   :book: ：这边解释了一个leetcode题目的常见问题：数组传递的都是指针（实参），所以对函数里对数组的修改是有效的（而不是，退出该函数，修改就消失了，形参的问题）

   所以，传递最新数组值，就能判断操作是否正确（至于该值后面的数组元素就不考虑了）。

   <img src="pic\image-20200701153521826.png" alt="形参和实参的传递" style="zoom:67%;" />

   :boxing_glove:：双指针真好用:+1:

8. 题328：[奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/)<a name="num328"></a>

   <img src="pic\image-20200701165032642.png" alt="题328" style="zoom:67%;" />

   一开始没有理解原地的意思（实际上，链表的操作好像都是原地的）。

   空间复杂度O(1)：可以创建常量个变量；时间复杂度O(nodes)：遍历一次

   具体思路很简单：设置两个指针，分别代表奇数链表、偶数链表，然后遍历链表，将他们拆分成两个链表即可，最后将偶数链表插入到奇数链表尾就可以了，我采用的是3指针：一个代表奇数链表的当前结点odd、一个代表偶数链表的当前结点even、一个代表当前结点curr。

   :warning:：特别要注意的是，对于每个当前结点，加入到对应的链表后，要将next指针清除掉，即`curr.next = null;`（这样主要是为了防止偶数尾结点和奇数尾结点产生循环）

   <img src="pic\image-20200701170039436.png" alt="死循环" style="zoom:67%;" />

   题解的方法更优雅；主要是关注到，只需要将even从链表中剔除，那么通过even来遍历，而odd做辅助就行，大致思路和我差不多，实现起来更简单。

   :boxing_glove:：官方解法好优雅，学不来:pensive:，只能多看看

9. 题876：[链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)<a name="num876"></a>

   <img src="pic\image-20200702105909505.png" alt="题876" style="zoom:67%;" />

   我的思路：遍历链表求得链表长度，再次从头开始找到中间结点。

   缺点：当链表很长时，将花费很多时间在第二次遍历上。

   更优的思路：快慢指针解法，快指针每次走一步，慢指针每两次走一步，那么快指针遍历完后，慢指针一定指向中间结点。

   而且，官方的题解的解法比我实现的更好：

   ```java
   ListNode first = head, second = head;	// 快慢指针
   while(first != null && first.next != null){	// 一次走两步的遍历
       second = second.next;
       first = first.next.next;
   }
   return second;
   ```

   :boxing_glove:：链表题要考虑是否能用双指针/快慢指针

10. 题11：[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)<a name="num11"></a>

    <img src="pic\image-20200702133221610.png" alt="题11" style="zoom:67%;" />

    首先拿到题目，先将题目抽象了，本质上是：求数组中两个结点 `(min(node1, node2)) * (index1 - index2)`（我能分析到这步，但是接下去就不知道该如何做了）

    官方题解：**双指针**，一个首head、一个尾tail，开始遍历，直到两个指针相交。那么这两个结点开始如何移动呢？接着我的分析，head从0开始，tail从len-1，开始，先计算最远的两个结点构成的面积，然后移动两个结点之间数值小的那个索引，即`num[head], num[tail]`中小的head/tail，eg：num[head] = 1, num[tail] = 8，那么就是head++，这构成了移动条件。

    证明选择较小的移动是正确的：

    $\because area = (tail - head) * min(num[tail], num[head])$，面积值由两部分组成，两者的距离和两者的值，所以一开始选择首尾，前一个数最大，循环过程中开始缩小，且每次缩小数都-1。

    为啥选择值小的那个index移动？ 反例，如果选择值大的index移动，那么 前一个乘数变小，后一个乘数**只能保持小于等于**（因为是min，所以取决于最小，因为值大的移动，那么如果移动到更大的一个值，也无济于事；如果移动到比原来小的值更小） ；$\therefore$ 选择值小的index移动，那么min才可能会变大

    $\therefore$ 这样的算法是正确的。[这个题解讲的很好]( https://leetcode-cn.com/problems/container-with-most-water/solution/container-with-most-water-shuang-zhi-zhen-fa-yi-do/ )

    :boxing_glove: 算法实现很简单，具体的分析和证明很重要（这题就是很主要在设计算法）。我能将题目抽象出来，并且分析出了关键的影响面积的因素，但是由于没有考虑到双指针的解法，所以就无从下手，所以:bulb: 双指针还是要多练练。:bulb: 并且，选择移动的条件也是算法的关键。

11. 题7：[整数反转](https://leetcode-cn.com/problems/reverse-integer/)<a name="num7"></a>

    <img src="pic\image-20200703105820590.png" alt="题7" style="zoom:67%;" />

    整数反转，一开始的思路是转换成string类型，倒置后再转换成int类型，但int转string效率不高。所以转而使用数学方法——不断取余，递增，相除循环。:key:最关键的是，要对溢出进行判断，输入是不会溢出的，但是倒置之后可能会溢出：向上溢出，向下溢出，所以要提前判断`Integer.MAX_VALUE / 10`和`Integer.MIN_VALUE / 10`，具体看代码实现。

    :boxing_glove:对于基础算法还是要记得：普通的数字倒转。

12. 题24：[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)<a name="num24"></a>

    <img src="pic\image-20200703123904443.png" alt="题24" style="zoom:67%;" />

    这个题我的思路是，迭代解法，用了3指针：head、second、temp，head指向第一个要替换的结点，second指向第二个要替换的结点，temp指向前面已经替换好的链表尾。还设置了dummy（哨兵结点），用来保存头结点，方便返回。具体画图就可得。

    官方提供了递归的解法：使用了两个指针。明确终止条件：head和head.next为null；调用单元：head和next进行交换，其中head的next指向后面已经交换好的链表头；返回值，后面交换完成的链表头。[这个写的很好，特别是关于递归的基础]( https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/hua-jie-suan-fa-24-liang-liang-jiao-huan-lian-biao/ )

    :book:递归的解题思路：需要分析出：1. 终止条件（一般在函数头指明）；2. 调用单元：一般在中间部分，需要具体分析，且包括递归调用；3. 返回值：一般出现在函数尾部，也一般是整个函数的返回值

    <img src="pic\image-20200703123829758.png" alt="递归图解" style="zoom: 67%;" />

    :boxing_glove:递归如何写优雅需要学习

13. 题121：[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)<a name="num121"></a>

    <img src="pic\image-20200718221014141.png" alt="image-20200718221014141" style="zoom:67%;" />

    我的解法：暴力解:sweat:，时间复杂度：O(n^2)

    聪明的解法：一次遍历，遍历的点是要卖出的点，那么其所属的**历史最低点**就是最优的买入点，两者的差值就是该点下获利最多的情况。那么维护一个`minprice`——历史最低点；`maxprofit`——获利最大值。（历史最低点：就是在点之前，价格最低的点）

    :boxing_glove:这种数学性质的题比较灵活，很明显暴力解不是最优，但是能解决问题——所以应该先实现暴力解法。然后去分析更优解

14. 题283：[移动零](https://leetcode-cn.com/problems/move-zeroes/)<a name="num283"></a>

    <img src="pic\image-20200718225955189.png" alt="image-20200718225955189" style="zoom:67%;" />

    我的解法：一次遍历，利用两个指针，`first`——用来遍历，`second`——用来指示最新数组非零数和零数之间的间隔。当遇到0值的时候跳过，遇到非0值得时候first和second所指示的值交换——具体看代码。[讲的很好的题解]( https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/ )

    <img src="pic\283_answer_gif.gif" alt="一次遍历的动图" style="zoom:67%;" />

15. 题35：[搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)<a name="num35"></a>

    <img src="pic\image-20200806111428332.png" alt="image-20200806111428332" style="zoom: 67%;" />

    题目本身没啥难度，但是可以根据这个接触**二分查找**

    我的解法：:cold_sweat:暴力解​，时间复杂度最差会到O(n)

    :+1:二分查找：时间复杂度是O(logn)，认识的关键是**严格小于目标数的都不可能是解**，只有大于目标的才有可能是解，然后不断收缩 right 的范围，并更新解索引；当遇到小于目标值时，单纯缩小left范围

16. 题704：[二分查找](https://leetcode-cn.com/problems/binary-search/)<a name="num704"></a>

    <img src="pic\image-20200806173503684.png" alt="image-20200806173503684" style="zoom:67%;" />

    很典型的二分查找题，不需要变型，直接套用即可。

17. 题34：[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)<a name="num34"></a>

    <img src="pic\image-20200807101918176.png" alt="image-20200807101918176" style="zoom:67%;" />

    典型的二分查找寻找边界的问题，具体见之前的整理

18. 题69：[x 的平方根](https://leetcode-cn.com/problems/sqrtx/)<a name="num69"></a>

    <img src="pic\image-20200807112353923.png" alt="image-20200807112353923" style="zoom:67%;" />

    求平方根，选择使用了二分查找。类似于普通的二分查找的方式，但是由于一定是有解的，所以不会返回-1，而是等到循环结束之后，指针指向的值就是正解。

    :bulb:可以在纸上模仿运行一下，看边界条件和返回值。

    查找边界：[1, x - 1]（排除了0，1之后）,双闭区间，所以循环是`left <= right`，并且最后由于循环停止条件为`left = right + 1`，所以正解为`left-1`处

    :boxing_glove:其余方法是数学原理

19. 题441：[排列硬币](https://leetcode-cn.com/problems/arranging-coins/)<a name="num441"></a>

    <img src="pic\image-20200809114804908.png" alt="image-20200809114804908" style="zoom:67%;" />

    这题要解出不难，暴力解、数学解、二分查找解（主要为了练习这个）

    :weary: 暴力解：从1向上加直到和大于指定的n，就退出循环，时间复杂度为O(n/2)=O(n)

    :pensive: 数学解：题目原理就是等差数列：1, 2, 3,....，公式为(1+x)x/2 <= n，求解x的最大值，那么用一元二次方程的求解即可。这个时间复杂度最低，O(1)

    :happy: 二分查找：从1~n不断地寻找符合要求的 x，本质上就是二分查找，只不过判断条件从简单的大小值判断变成了`(1+mid)*mid/2 == n`的判断。时间复杂度为O(logn)

    :warning:需要注意值的溢出问题，由于n可能会很大，而其中又有乘法操作，所以很可能溢出，那么需要将之转换成long

20. 题offer 53-1：[在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)<a name="offer53-1"></a>

    <img src="pic\image-20200809135803349.png" alt="image-20200809135803349" style="zoom:80%;" />

    该题本质上是在某个有序数组（数字可重复）中查询一个 target的左右边界，然后相减就能求出在数组中的个数（注意其本身），与[题34](#num34)本质上一致，做本题主要是为了巩固知识。

    时间复杂度：O(logn)

21. 题104：[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)<a name="num104"></a>

    <img src="pic\image-20200811112830845.png" alt="image-20200811112830845"  />

    二叉树的深度求解，是二叉树很重要的性质之一

    有两种解法：

    - 深度优先遍历：根据 DFS 的模板，可以将其修改为求二叉树的深度求解方法
    - 广度优先遍历：构建一个队列，存放当前层的所有节点，然后根据该链表的size，取出该层的所有节点——从队头取，将其孩子节点全部入队——从队尾入，当这一层的所有节点全部遍历后，该队列的节点就是下一层的全部节点，**如此迭代，直到队列为空——说明该层一个节点也没有**，那么就是遍历结束了

22. 题144：[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)<a name="traversal_binaryTree"></a>

    <img src="pic\image-20200811163607168.png" alt="image-20200811163607168" />

    递归算法很简单，按照模板即可。

    迭代算法的研究：迭代算法由于没有递归，所以需要自行创建**栈**，来实现类似于递归的方法

    整体思路：从根节点开始遍历，最先将其压入栈中，然后开始遍历，**在保证栈不为空的前提下**，迭代弹出栈顶——根节点，然后将其的右孩子、左孩子分别压入栈，因为按照遍历是先左后右的，所以是先入栈右后入栈左。具体还要看代码实现。

    => 然后将代码稍微修改成功了三种遍历统一的格式

23. 题94：[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

    <img src="pic\image-20200811163607168.png" alt="image-20200811163607168"  />

    递归算法很简单，按照模板即可。

    迭代算法的研究：从根节点开始遍历左节点，一直深入下去，每个经过的节点都入栈，直到最左孩子节点，不存在左孩子，然后该叶子节点出栈，然后判断其右孩子节点，继续深入，如果也为空，那么就继续出栈，直到堆栈为空具体看[题解](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/)

24. 题145：[二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

    <img src="pic\image-20200811163627672.png" alt="image-20200811163627672"  />

    递归算法很简单，按照模板即可。

    迭代算法的研究：看官方题解不大能明白，但是看到了一个很优秀的思路。

    思路：从前序遍历出发，前序遍历的遍历顺序是：根 -- 左 -- 右，且结果是尾部插入；那么如果是**头插，那么遍历顺序就变成了 右 -- 左 -- 根**，**前序遍历的遍历顺序是先左后右，那么遍历顺序修改成先右后左**，就会将结果变成 左 -- 右 -- 根。所以整体的思路是：

    - 结果插入方法是：头插
    - 遍历顺序是根-右-左

    具体实现看代码

    :book:总结：上面三题，是对二叉树的遍历，有递归方法：代码简单，但默认使用了堆栈，时间复杂度并不低，且递归的终止条件相对难找；迭代方法：代码复杂，但是最后做到了统一，记忆也相对方便。

25. 题559：[N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)<a name="num559"></a>

    <img src="pic\image-20200813112516093.png" alt="image-20200813112516093" style="zoom:80%;" />

    有两种方法：递归求解，是对二叉树的深度求解的一种扩展。

    非递归，本质是广度优先遍历 BFS，也是对二叉树的深度求解的BFS方法一种扩展（代码改动量更少）

26. 题102：[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)<a name="num102"></a>

    <img src="pic\image-20200813134350913.png" alt="image-20200813134350913"  />

    算是对BFS的实现，是基本实现方法，具体看题104的解法2

    :alarm_clock:注意对集合的嵌套使用，详见java笔记

27. 题Offer32 - I. [从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)<a name="offer32-1"></a>

    <img src="pic\image-20200814132907876.png" alt="image-20200814132907876" style="zoom:80%;" />

    最基本的层次遍历，使用 BFS 即可

28. 题Offer32 - III. [从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)<a name="offer32-3"></a>

    <img src="pic\image-20200814131536519.png" alt="image-20200814131536519" style="zoom:80%;" />

    与上题的区别是，之字形打印二叉树，本质上还是 BFS 的层次遍历，只是在获得遍历值的时候，有所区别，有两种策略：

    1. 获得某一层的所有节点数组后，判断当前是奇数层 or 偶数层，偶数层就将该数组倒置，然后再加入到数组中
    2. 在插入数组的时候，如果是偶数层，就倒着插——头插法；如果是奇数层，就正着插——尾插法

29. 题226. [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)<a name="num226"></a>

    <img src="pic\image-20200815160956997.png" alt="image-20200815160956997" style="zoom: 67%;" />

    翻转二叉树，本质上就是遍历所有的节点，将所有节点的左右孩子互换即可。所以可以用的方法有：递归、迭代，然后在基本的模板上面进行修改。具体看代码，总体来说较为简单。

30. 题617. [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)<a name= "num617"></a>

    <img src="pic\image-20200815190132527.png" alt="image-20200815190132527" style="zoom:67%;" />

    方法显然有两种，但是如何将思路理清除，比较难。[官方题解很详细]( https://leetcode-cn.com/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode/ )

    我觉得本题的关键在于，如何处置每个树中独有的点，并且要明确哪棵树作为被加树

    以t1为被加树，开始同步遍历两棵树，遇到某个点是t1没有的，t2有的，那么就将t2的节点直接复制给t1，这之后的子树就默认跟着t1存在了；如果是t1有，t2没有的，就不用加，直接跳过即可

    递归法：还是在DFS 遍历的基础上进行修改，关键是确定终止条件：`t1 == null 且 t2 == null`，直接返回 null；否则，哪个非null，就返回哪个，然后返回的值都赋值给t1的左/右节点即可

    **迭代法：比较复杂，大框架就是BFS遍历，但是入队的节点从一个节点变成两个节点（数组形式），并且遇到某个点是t1没有的，t2有的，那么就将t2的节点直接复制给t1，且不需要入队了；如果t1、t2均存在，就入队继续遍历。**

31. 题654. [最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)<a name="num654"></a>

    <img src="pic\image-20200816104341372.png" alt="image-20200816104341372" style="zoom:80%;" />

    题意不难理解，就是根据数组创建一颗最大子树，保证根节点在该数组该部分值是最大。本质上是创建二叉树，创建二叉树的直观方法是：递归法

    递归操作：获得当前数组中的最大值，创建该树的根节点，以该最大值的索引为中间值，划分左右孩子节点，然后递归调用该函数，创建以其孩子节点为根节点的子树

    递归终止条件：传递的数组中不存在元素 `nums.length == 0 -> return null`

    :book:递归真的方便:+1: ，以后确定要选择递归的时候，可以先尝试写一下，然后就会慢慢明确思路

32. 题105. [从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)<a name="num105"></a>

    <img src="pic\image-20200816142204298.png" alt="image-20200816142204298" style="zoom:90%;" />、

    有两种解法：递归、迭代

    1. 递归比较直观，需要明确前序遍历和中序遍历之间的关系——实现中有具体的解释
    2. 迭代思路巧妙：未完

33. 题109. [有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)<a name="num109"></a>

    <img src="pic\image-20200818215225849.png" alt="image-20200818215225849"  />

    它说的高度平衡是一个幌子，只要你的根节点是中值，那么其左右子树深度的差距最多1。所以题目的关键变成了如何找中值，找到中值后，其左边的就是左子树、右边的就是右子树，所以整体的思路是很直观的——用递归的方法就可以做到。

    中值的找法：快慢双指针法，当快指针到链表尾部后，慢指针就到了中值的位置处

34. 题112. [路径总和](https://leetcode-cn.com/problems/path-sum/)<a name="num112"></a>

    <img src="pic\image-20200819103836281.png" alt="image-20200819103836281"  />

    能够自然的想到递归和迭代，但是自己写却写不出来:weary:，于是只能看题解

    迭代：在原来 BFS 的基础上，**增加一个链表**，用来存放从根节点到当前节点的路径值，这个是与遍历的链表是同步入队和出队的。然后BFS遍历整棵树，直到找到某个叶子节点，所以其他操作都类似 BFS 模板

    递归：递归的操作：如果当前节点是目标路径中的一个节点，那么其孩子路径就只需要 `target - current.val`，然后递归调用即可

    ​		   递归的终止条件：该节点为 null——返回false；该节点为叶子节点——判断当前值是否等于目标值；

35. 题1480. [一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)<a name="num1480"></a>

    <img src="pic\image-20200819103456625.png" alt="image-20200819103456625" style="zoom: 80%;" />

    比签到题还签到题（被递归虐的太惨了，来找回点信心:cry: ），创建一个额外的数组，然后一次遍历就可以求解

    在看题解的时候，注意到是否原地操作的讨论——理论上，进行求和运算，不建议在原来的数组上进行操作，因为原数组可能还有其它用处——涉及到面试小技巧，与面试官沟通确认该题的操作问题。

36. 题111.[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)<a name="num111"></a>

    <img src="pic\image-20200821160613311.png" alt="image-20200821160613311"  />

    该题目的有一点小坑：需要明确叶子节点的概念——没有左右子节点的节点。

    相应的就有几个特殊情况要处理：`root==null`直接返回0，`root`没有左右孩子，直接返回1；`root`存在一个孩子节点，返回该孩子节点的深度；`root`存在左右孩子，返回两个孩子子树的深度小的那个。

37. 题100. [相同的树](https://leetcode-cn.com/problems/same-tree/)

    <img src="pic/image-20200824142509962.png" alt="image-20200824142509962" style="zoom: 80%;" />

    这题很容易就找到递归的终止条件：两者均为null——true；一个为null，一个非null——false；全为非null，但是值不相等——false；非null，值相等——递归看其左右子树的情况                                                                                                                                                                                                                                                                                                                                                                

38. 题136. [只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

    <img src="pic/image-20200824151555964.png" alt="image-20200824151555964" style="zoom:80%;" />

    如果可以使用线性的空间，那么可以用集合的特性来做；用哈希表存储——都需要花费O(N)的空间，所以都不适合

    ——用异或操作——简直是天才！

    异或的特性是：两个相同的数进行异或的值就是0，而题目所给定的数组元素只会出现2次/1次，所以只需要做一次遍历，将所有数进行异或，结果就是出现一次的那个数被留下来了。如果结果是0——唯一出现的一个数就是0/题目给的数组有问题（所有数均出现两次）

39. 题101. [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)<a name="num101"></a>

    <img src="pic\image-20200827185456463.png" alt="image-20200827185456463"  />

    这题很早之前就接触过，但是当时没想好怎么写，但是今天打开这题发现可以写，就用递归解法很快实现了——真是玄学

    递归解法：需要传递的是左右节点的参数，所以需要重新写一个函数，使之符合参数要求——题解有点难懂，它是从根节点开始构造了两棵左右对称的树，然后比较这两棵树是否相等，而我是从根节点的左右节点开始，比较该左右节点构成的子树是否是对称的，是按照原来树的步骤进行判断的感觉更能理解一点

    迭代解法：和遍历类似，构造一个队列，队头出队，队尾入队，区别就是**每次出队都是出两个，每次入队都是入四个**，出队还是队首出，一次出两个，入队就是左边的左孩子节点和右边的右孩子节点入队，左边的右孩子节点和右边的左孩子节点入队

40. 题657. [机器人能否返回原点](https://leetcode-cn.com/problems/robot-return-to-origin/)<a name="num657"></a>

    <img src="pic\image-20200828095258847.jpg" alt="image-20200828095258847"  />

    这题没有啥意思，只需要了解到题目的本质：从原点出发最后要回到原点——很显然，每左移一格，必须要右移一格，反之一样；上下也是如此；所以只需要计算`L`和`R`的出现次数，`U`和`D`的出现次数是否是一致的可以判断了

41. 题965. [单值二叉树](https://leetcode-cn.com/problems/univalued-binary-tree/)<a name="num965"></a>

    <img src="pic\image-20200828104807047.png" alt="image-20200828104807047"  />

    就是看整个棵树的值是否都一样——本质上还是遍历二叉树即可

    :ticket: 小技巧，如果该树是单值，那么根节点的值和其他值都一样——所以，可以将根节点的值作为**标值**，如果在遍历过程中，与该值不一样，可以结束遍历直接返回

42. 题344. [反转字符串](https://leetcode-cn.com/problems/reverse-string/)<a name="num344"></a>

    <img src="pic\image-20200829142222241.png" alt="image-20200829142222241"  />

    题目本身很简单，从两边开始进行替换即可，只需要关注终止条件即可。

    也可以用递归求解，只需要再写一个函数满足参数传递要求即可。

43. 题198. [打家劫舍](https://leetcode-cn.com/problems/house-robber/)<a name="num198"></a>

    <img src="pic\image-20200829154123064.png" alt="image-20200829154123064"  />

    典型的动态规划的题，分3步走：

    1. 分析子问题

       求n个房子的偷窃最优解，那么可以缩小成从k个房子偷窃的最优解，k可以是0~n，发现如果1个房子的最优解求出了，那么2个房子的也可以求解——选第一个or第二个，那么3个房子的也可以求解，.....以此类推

    2. 写出递推关系——需要实际演算一下

       <img src="pic\image-20200829155106268.png" alt="image-20200829155106268" style="zoom:67%;" />

    3. 确定DP数组的计算顺序：自底向上 or 自顶向下

       一般都使用自底向上，维护一个DP数组，从0开始不断的扩大子问题的规模——即从0个房子开始偷起，直到全部房子的都考虑一遍

    => 该题还可以再优化一下，由于需要维护一个DP数组，所以空间复杂度为O(n)，但是实际上，每次在求当前的最优解时，只需要考虑到其前一个和前前个的最优解，而再前面的就不在考虑了，所以可以将数组改成两个变量

44. 题70. [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

    <img src="pic/image-20200831220517312.png" alt="image-20200831220517312"  />

    典型的动态规划题，和上题类似。确定特殊边界：n=0时，1种走法；n=1时，1种走法；

    明确递推关系式：当台阶有k个时，其最后一步有两种走法：走一步+之前的k-1个台阶的走法；走两步+之前k-2个台阶的走法。因此：`f(k) = f(k-1)+f(k-2)`,所以当前的解只与前面2个的解有关系——只需要两个变量即可

    所以时间复杂度为`O(n)`，空间复杂度为`O(2)=O(1)`

45. 题134. [加油站](https://leetcode-cn.com/problems/gas-station/)<a name="num134"></a>

    <img src="pic\image-20200907215633664.png" alt="image-20200907215633664" style="zoom: 80%;" />

    <img src="pic\image-20200907215711380.png" alt="image-20200907215711380" style="zoom:80%;" />

    我的暴力解法： O(N*N)，简单直白（题解太难了，之后补上）

    基本的：从0点开始遍历所有点，从该点开始模拟加油和消耗过程。

    如果当前节点开始的gas<cost，那么直接选择下一个节点；否则的话，就从当前节点开始走，遇到当前油量无法到达下一个节点的，那么就跳出该次循环，而去选择下一个开始节点。

46. 题108. [将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

    <img src="pic\image-20200908144537726.png" alt="image-20200908144537726"  />

    题目要求构建一颗二叉搜索树，已经是按照升序排列的，那么完全可以按照数组的顺序构造出一颗二叉搜索树——虽然这棵树退化成一个线性链表

    然后题目又规定是一颗高度平衡的二叉搜索树，那么需要考虑其左右子树的**对称性**——自然就能想到从中间节点开始作为根节点，然后两边开始分开进行二分查找，然后构建左右节点。

    ps： 果然二叉树的题还是简单的，动态规划、贪心太难了:weary:

47. 题46. [全排列](https://leetcode-cn.com/problems/permutations/)

    <img src="pic\image-20200909212805205.png" alt="image-20200909212805205" style="zoom: 80%;" />

    典型的**回溯算法**题，没有了解到回溯算法之前，看到该题就想到了DFS，但是该如何进行DFS就犯难了。看了题解，了解到是用回溯算法

    <img src="https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="image.png" style="zoom: 50%;" />

    ——回溯算法都需要画出树形结构，然后根据此解题。

    - 每一个结点表示了**求解全排列问题的不同的阶段**，这些阶段通过变量的不同的值体现，这些变量的不同的值，称之为**状态**；

    - 使用深度优先遍历有**回头**的过程，在回头以后， **状态变量需要设置成为和先前一样** ，因此在回到上一层结点的过程中，需要**撤销上一次的选择**，这个操作称之为**状态重置**；

    - 深度优先遍历，借助系统栈空间，保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，*path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈；*

      （深度优先遍历通过回溯操作，实现了全局使用一份状态变量的效果）

    （——解释的挺好）

48. 题771. [宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones/)<a name="num771"></a>

    <img src="pic\image-20200923113230610.png" alt="image-20200923113230610"  />

    题目本身很简单，有两种方法：

    - 暴力求解：时间复杂度为`O(S.length * J.length)`
    - 利用hash表数据结构求解：将J存放在一个`hashSet`中——`hashSet.add(j)`，然后遍历S，看每个元素在hashSet中是否存在——`hashSet.contains(s)`，所以时间复杂度为`O(S.length + J.length)`

49. 题349. [两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)<a name="num349"></a>

    <img src="pic\image-20200923185822100.png" alt="image-20200923185822100"  />

    利用哈希集合将重复的数组元素删除，然后比较两个哈希表的交集放在另外一个哈希集合中，最后将哈希集合一个个输出变成数组，作为返回值返回

50. 题142. [环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

    

    <img src="pic\image-20201010201016946.png" alt="image-20201010201016946" style="zoom: 67%;" />

    <img src="pic\image-20201010201041037.png" alt="image-20201010201041037" style="zoom:67%;" />

    **对于链表题，首先就要想到双指针**，例如，寻找距离尾部的第K个节点、寻找环的入口（本题）。

    总结来说是双指针+双相遇法。理论上来讲是数学法：

    - 设置快慢指针，fast指针每次走2步；slow指针每次走1步

    - 第一次相遇：情况：如果不存在环，那么fast和slow是不会相遇的，fast或者fast.next能遍历到链表的尾部（如果存在环，那么尾部一定指向前面的某个地址）；fast和slow相遇，那么就是存在环，并且可以计算出相遇后f、s走的距离：`f = 2s, f = s +nb`（b是环的大小，n是走的环的次数，因为既然相遇了，那么s和f就在同一个点，那么f比s多走的就是环的倍数），那么`f = 2nb, s = nb`，而进一步我们需要求环的起点，从起点开始走，到入口的步数是`a+nb`（a是从起点到环起点的步数），那么s已经走了nb，那么再走a就是到环起点了；但是a不知道，如何控制呢，那么让fast节点从起点开始，每次走1步，那么两者相遇时，就是环起点了。
    - 第二次相遇：fast指针从起点开始，每次走1步（f = 0）；slow从刚才继续走(s = nb)，相遇点就是环的起点，即f = a; s = a+nb，都是到环的起点

    能想到这个方法的人真是天才啊！

51. 

## bottom